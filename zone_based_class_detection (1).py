# -*- coding: utf-8 -*-
"""Zone_based_Class_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Utg1ASfeBvj58mlSGadVFlfNUWqfKDhC
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install ultralytics opencv-python numpy deep-sort-realtime

import cv2
import time
import datetime
from pathlib import Path
from ultralytics import YOLO
from deep_sort_realtime.deepsort_tracker import DeepSort
import argparse
from google.colab.patches import cv2_imshow


# ----------------------------
# CONFIG
# ----------------------------

# --- Class & Color Configuration ---
# This dictionary acts as a fallback set of requirements if the user
# provides an empty --classes argument.
DEFAULT_REQUIRED_LEFT  = {"helmet", "shoes", "goggles", "safety_vest","pvc_suit"}
DEFAULT_REQUIRED_RIGHT = {"helmet", "shoes", "goggles", "safety_vest", "pvc_suit"} # Example requirements for the right zone


# Class name aliases to normalize names from the model to a standard form.
ALIASES = {
    "person": {"person", "Person"},
    "helmet": {"helmet", "hardhat", "safety_helmet", "Helmet"},
    "safety_vest": {"vest", "safety_vest", "Safety_Vestr"},
    "no_helmet": {"no_helmet", "no_safety_helmet", "no_hardhat", "NO_helmet"},
    "no_safety_vest": {"no_vest", "no_safety_vest", "NO_Vestr"},
    # Add other aliases as needed
    "shoes": {"shoes", "safety_shoes", "boots","Safety Shoes"},
    "goggles": {"goggles", "safety_goggles", "glasses", "eye_protection","Safety Goggles"},
    "no_safety_shoes": {"no_shoes", "no_safety_shoes", "no_boots", "NO_safetyshoes"},
    "no_goggles": {"no_goggles", "no_safety_goggles", "no_eye_protection", "NO_goggles"},
    "pvc_suit": {"pvc_suit", "suit"},
    "no_pvc_suit": {"no_pvc_suit", "no_suit"},
}

# --- Visual Configuration ---
# Colors for bounding boxes and labels (B, G, R)
CLR_OK = (0, 200, 0)
CLR_MISS = (0, 0, 255)
CLR_LINE = (255, 255, 255)
CLR_MISS_TEXT = (255, 255, 255)
CLR_MISS_BG = (0, 0, 255)

# ----------------------------
# Helper Functions
# ----------------------------

def canonicalize(name: str) -> str:
    """Converts a class name to its canonical form using the ALIASES map."""
    n = name.lower().replace(" ", "_")
    for canon, synonyms in ALIASES.items():
        if n == canon or n in synonyms:
            return canon
    return n

def center_of_box(xyxy):
    """Calculates the center point of a bounding box."""
    x1, y1, x2, y2 = xyxy
    return (int((x1 + x2) / 2), int((y1 + y2) / 2))

def point_side_of_line(px, py, x1, y1, x2, y2):
    """Determines which side of a vertical line a point is on. Positive -> LEFT, Negative -> RIGHT."""
    return (x2 - x1) * (py - y1) - (y2 - y1) * (px - x1)

def inside_bbox(point, bbox):
    """Checks if a point is inside a bounding box."""
    px, py = point
    x1, y1, x2, y2 = bbox
    return x1 <= px <= x2 and y1 <= py <= y2

def draw_label(img, text, x, y, color=(255, 255, 255), bg=(0, 0, 0)):
    """Draws a text label with a background on an image."""
    (tw, th), _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
    cv2.rectangle(img, (x - 5, y - th - 5), (x + tw + 5, y + 5), bg, -1)
    cv2.putText(img, text, (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)


def ensure_log_file(path):
    """Creates the log file and writes a header if it doesn't exist."""
    if not Path(path).exists():
        with open(path, "w") as f:
            f.write("--- PPE VIOLATION LOG ---\n")
            f.write("Timestamp           | Person ID | Zone      | Missing PPE\n")
            f.write("--------------------+-----------+-----------+-----------------\n")


# ----------------------------
# Main Detection Logic
# ----------------------------

def main(args):
    """Main function to run the PPE detection."""
    if args.log:
        ensure_log_file(args.log)

    # Load the YOLO model
    try:
        model = YOLO(args.model)
    except Exception as e:
        print(f"Error loading model: {e}")
        return

    # Open the video file
    cap = cv2.VideoCapture(args.video)
    if not cap.isOpened():
        print(f"Error: Cannot open video file at {args.video}")
        return

    # Initialize the DeepSort tracker
    tracker = DeepSort(max_age=70, n_init=3)

    # Get video properties
    W = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    H = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    FPS = cap.get(cv2.CAP_PROP_FPS)

    # Set up video writer to save the output
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(args.output, fourcc, FPS, (W, H))

    # =================================================================================
    # MODIFIED LOGIC: Dynamically determine which classes to detect and require per zone
    # =================================================================================
    required_left_ppe = set()
    required_right_ppe = set()

    # Check if user actually specified classes (non-empty)
    left_classes_specified = bool(args.classes_left) and any([c.strip() for c in args.classes_left])
    right_classes_specified = bool(args.classes_right) and any([c.strip() for c in args.classes_right])


    if left_classes_specified:
        print(f"User specified classes for LEFT zone: {args.classes_left}")
        for cls_name in args.classes_left:
            canon_name = canonicalize(cls_name)
            if canon_name.startswith("no_"):
                required_left_ppe.add(canon_name[3:])
            else:
                required_left_ppe.add(canon_name)
        print(f"Required PPE for LEFT zone set to: {required_left_ppe}")
    else:
        print("No specific classes provided for LEFT zone. No detection will be performed in this zone.")


    if right_classes_specified:
        print(f"User specified classes for RIGHT zone: {args.classes_right}")
        for cls_name in args.classes_right:
            canon_name = canonicalize(cls_name)
            if canon_name.startswith("no_"):
                required_right_ppe.add(canon_name[3:])
            else:
                required_right_ppe.add(canon_name)
        print(f"Required PPE for RIGHT zone set to: {required_right_ppe}")
    else:
        print("No specific classes provided for RIGHT zone. No detection will be performed in this zone.")

    # Get class indices for detection based on specified classes for *each* zone
    model_class_map = {canonicalize(name): idx for idx, name in model.names.items()}

    detect_classes_left_indices = []
    if left_classes_specified:
        for ppe_type in required_left_ppe:
            # Add both the PPE and its 'no_' version for detection in the left zone
            if ppe_type in model_class_map:
                detect_classes_left_indices.append(model_class_map[ppe_type])
            if f"no_{ppe_type}" in model_class_map:
                detect_classes_left_indices.append(model_class_map[f"no_{ppe_type}"])
        # Always detect 'person' in the left zone if any classes specified
        if "person" in model_class_map:
             detect_classes_left_indices.append(model_class_map["person"])


    detect_classes_right_indices = []
    if right_classes_specified:
        for ppe_type in required_right_ppe:
            # Add both the PPE and its 'no_' version for detection in the right zone
            if ppe_type in model_class_map:
                detect_classes_right_indices.append(model_class_map[ppe_type])
            if f"no_{ppe_type}" in model_class_map:
                detect_classes_right_indices.append(model_class_map[f"no_{ppe_type}"])
        # Always detect 'person' in the right zone if any classes specified
        if "person" in model_class_map:
             detect_classes_right_indices.append(model_class_map["person"])

    # Combine all class indices to pass to the single model.predict call later
    # The filtering by zone will happen after prediction
    all_detect_class_indices = list(set(detect_classes_left_indices + detect_classes_right_indices))

    # =================================================================================
    # END OF MODIFIED LOGIC
    # =================================================================================


    # Define the divider line (center of the screen)
    x_mid = W // 2
    divider = [x_mid, 0, x_mid, H]
    zone_names = ("LEFT", "RIGHT")

    frame_count = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        frame_count += 1

        detections_for_tracker = []
        ppe_items = []

        # Only perform detection if there are classes to detect in at least one zone
        if all_detect_class_indices:
            results = model.predict(frame, conf=args.conf, iou=0.5, classes=all_detect_class_indices, verbose=False)

            dets = results[0].boxes


            if dets is not None and len(dets) > 0:
                for i in range(len(dets)):
                    xyxy = dets.xyxy[i].cpu().tolist()
                    cls_id = int(dets.cls[i].cpu().item())
                    conf = float(dets.conf[i].cpu().item())
                    class_name = canonicalize(model.names.get(cls_id, ""))

                    # Determine which zone the detection belongs to based on its center (use both cx,cy)
                    cx, cy = center_of_box(xyxy)
                    side = point_side_of_line(cx, cy, *divider)
                    zone = zone_names[0] if side > 0 else zone_names[1]

                    # Only process detections if the class was specified for that zone
                    is_person = (class_name == "person")

                    # handle 'no_X' canonical names: if detection is 'no_helmet' it'll appear as 'no_helmet'
                    def is_no_variant_for(variant_name, required_set):
                        return variant_name.startswith("no_") and variant_name[3:] in required_set

                    is_ppe_for_left = (zone == "LEFT" and left_classes_specified and
                                       (class_name in required_left_ppe or is_no_variant_for(class_name, required_left_ppe)))
                    is_ppe_for_right = (zone == "RIGHT" and right_classes_specified and
                                        (class_name in required_right_ppe or is_no_variant_for(class_name, required_right_ppe)))

                    if is_person or is_ppe_for_left or is_ppe_for_right:
                         if is_person:
                            w, h = xyxy[2] - xyxy[0], xyxy[3] - xyxy[1]
                            detections_for_tracker.append(([xyxy[0], xyxy[1], w, h], conf, class_name))
                         else:
                            ppe_items.append({"bbox": xyxy, "center": (cx, cy), "name": class_name})


        tracks = tracker.update_tracks(detections_for_tracker, frame=frame)

        for track in tracks:
            if not track.is_confirmed():
                continue

            track_id = track.track_id
            ltrb = track.to_ltrb()
            px1, py1, px2, py2 = map(int, ltrb)
            pcx, pcy = center_of_box(ltrb)

            side = point_side_of_line(pcx, pcy, *divider)
            zone = zone_names[0] if side > 0 else zone_names[1]

            # Only draw boxes and labels if classes were specified for this zone
            if (zone == "LEFT" and left_classes_specified) or (zone == "RIGHT" and right_classes_specified):
                required_ppe = required_left_ppe if zone == "LEFT" else required_right_ppe
                owned_ppe = {item["name"] for item in ppe_items if inside_bbox(item["center"], ltrb)}

                # Determine missing items based on required PPE for the zone
                missing_items = set()
                for required_item in required_ppe:
                    # If neither the positive nor the 'no_' variant is detected, treat as missing.
                    if required_item not in owned_ppe and f"no_{required_item}" not in owned_ppe:
                         missing_items.add(required_item)
                    elif f"no_{required_item}" in owned_ppe:
                         missing_items.add(required_item)


                color = CLR_MISS if missing_items else CLR_OK
                cv2.rectangle(frame, (px1, py1), (px2, py2), color, 2)

                # --- NEW: Single line with background and bigger text ---
                x, y = px1, py1 - 10
                base_text = f"ID: {track_id} ({zone}) PPE:"
                font = cv2.FONT_HERSHEY_SIMPLEX
                scale = 0.6        # Increased text size
                thickness = 2      # Increased thickness

                # compute text size for background
                text_size = cv2.getTextSize(base_text, font, scale, thickness)[0]
                overlay = frame.copy()
                cv2.rectangle(overlay, (x-2, y-16), (x + text_size[0] + 4, y+6), (0,0,0), -1)
                alpha = 0.6
                frame = cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0)

                cv2.putText(frame, base_text, (x, y), font, scale, (255,255,255), thickness)

                offset_x = x + text_size[0] + 10

                # Display required items with their status for the current zone
                for item in sorted(list(required_ppe)):
                    if item in owned_ppe and item not in missing_items:
                        status = "OK"
                        text_color = (0, 200, 0)  # Green
                    else:
                        status = "MISSING"
                        text_color = (0, 0, 255)  # Red

                    text = f" {item}:{status}"
                    tsize = cv2.getTextSize(text, font, scale, thickness)[0]
                    overlay = frame.copy()
                    cv2.rectangle(overlay, (offset_x-2, y-16), (offset_x + tsize[0] + 4, y+6), (0,0,0), -1)
                    frame = cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0)

                    cv2.putText(frame, text, (offset_x, y), font, scale, text_color, thickness)
                    offset_x += tsize[0] + 10

                if missing_items and args.log:
                    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    missing_str = ", ".join(sorted(list(missing_items)))
                    log_entry = f"{timestamp} | {track_id:<9} | {zone:<9} | {missing_str}\n"
                    with open(args.log, "a") as f:
                        f.write(log_entry)
            # else: zone not specified - we intentionally skip drawing PPE status for this zone

        # draw divider and zone labels (only if that zone has classes specified)
        cv2.line(frame, (divider[0], divider[1]), (divider[2], divider[3]), CLR_LINE, 2)
        if left_classes_specified:
             cv2.putText(frame, zone_names[0], (divider[0] - 80, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, CLR_LINE, 2)
        if right_classes_specified:
             cv2.putText(frame, zone_names[1], (divider[0] + 20, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, CLR_LINE, 2)

        cv2_imshow(frame)  # For Colab
        out.write(frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    out.release()
    cv2.destroyAllWindows()
    print(f"Processing complete. Output video saved to {args.output}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Selective PPE Detection using YOLOv8 and DeepSort.")
    parser.add_argument("--model", type=str, default="/content/best (3) (2).pt", help="Path to the YOLO model file.")
    parser.add_argument("--video", type=str, default="/content/drive/MyDrive/client_video/TATA1.mp4", required=True, help="Path to the input video file.")
    parser.add_argument("--output", type=str, default="output_video.mp4", help="Path to save the output video file.")
    parser.add_argument("--log", type=str, default="log.txt", help="Path to save the violation log file. Set to '' to disable.")
    parser.add_argument("--conf", type=float, default=0.3, help="Confidence threshold for object detection.")
    parser.add_argument("--iou", type=float, default=0.5, help="IoU threshold for non-maximum suppression.")

    # --- MODIFIED LINE ---
    # Both zone args default to empty lists -> if user doesn't pass classes for a zone, that zone will NOT detect anything.
    parser.add_argument(
        "--classes_left",
        nargs='*',
        default=["helmet","pvc_suit"],
        help="A list of specific classes to check for in the LEFT zone. Empty = no detection in left zone."
    )
    parser.add_argument(
        "--classes_right",
        nargs='*',
        default=[],
        help="A list of specific classes to check for in the RIGHT zone. Empty = no detection in right zone."
    )

    # Pass the arguments explicitly to parse_args
    args = parser.parse_args(["--video", "/content/drive/MyDrive/client_video/TATA1.mp4", "--output", "output_video.mp4", "--log", "log.txt", "--conf", "0.3", "--iou", "0.5",])
    main(args)