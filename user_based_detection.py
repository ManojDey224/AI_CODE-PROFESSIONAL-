# -*- coding: utf-8 -*-
"""user_based_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wNsGQqitaJLzyWJPxjCP7M2gspvMgVYt
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install ultralytics opencv-python numpy deep-sort-realtime

"""**USER BASED DETECTION WITH ZONE**:"""

import cv2
import time
import datetime
from pathlib import Path
from ultralytics import YOLO
from deep_sort_realtime.deepsort_tracker import DeepSort
import argparse
from google.colab.patches import cv2_imshow


# ----------------------------
# CONFIG
# ----------------------------
{"helmet", "shoes", "goggles", "safety_vest",}
# --- Class & Color Configuration ---
# This dictionary acts as a fallback set of requirements if the user
# provides an empty --classes argument.
DEFAULT_REQUIRED_LEFT  = {"helmet", "shoes", "goggles", "safety_vest",}
DEFAULT_REQUIRED_RIGHT = {"helmet", "shoes", "goggles", "safety_vest", } # Example requirements for the right zone


# Class name aliases to normalize names from the model to a standard form.
ALIASES = {
    "person": {"person", "Person"},
    "helmet": {"helmet", "hardhat", "safety_helmet", "Helmet"},
    "safety_vest": {"vest", "safety_vest", "Safety_Vestr"},
    "no_helmet": {"no_helmet", "no_safety_helmet", "no_hardhat", "NO_helmet"},
    "no_safety_vest": {"no_vest", "no_safety_vest", "NO_Vestr"},
    # Add other aliases as needed
    "shoes": {"shoes", "safety_shoes", "boots","Safety Shoes"},
    "goggles": {"goggles", "safety_goggles", "glasses", "eye_protection","Safety Goggles"},
    "no_safety_shoes": {"no_shoes", "no_safety_shoes", "no_boots", "NO_safetyshoes"},
    "no_goggles": {"no_goggles", "no_safety_goggles", "no_eye_protection", "NO_goggles"},
    "pvc_suit": {"pvc_suit", "suit"},
    "no_pvc_suit": {"no_pvc_suit", "no_suit"},
}

# --- Visual Configuration ---
# Colors for bounding boxes and labels (B, G, R)
CLR_OK = (0, 200, 0)
CLR_MISS = (0, 0, 255)
CLR_LINE = (255, 255, 255)
CLR_MISS_TEXT = (255, 255, 255)
CLR_MISS_BG = (0, 0, 255)

# ----------------------------
# Helper Functions
# ----------------------------

def canonicalize(name: str) -> str:
    """Converts a class name to its canonical form using the ALIASES map."""
    n = name.lower().replace(" ", "_")
    for canon, synonyms in ALIASES.items():
        if n == canon or n in synonyms:
            return canon
    return n

def center_of_box(xyxy):
    """Calculates the center point of a bounding box."""
    x1, y1, x2, y2 = xyxy
    return (int((x1 + x2) / 2), int((y1 + y2) / 2))

def point_side_of_line(px, py, x1, y1, x2, y2):
    """Determines which side of a vertical line a point is on."""
    return (x2 - x1) * (py - y1) - (y2 - y1) * (px - x1)

def inside_bbox(point, bbox):
    """Checks if a point is inside a bounding box."""
    px, py = point
    x1, y1, x2, y2 = bbox
    return x1 <= px <= x2 and y1 <= py <= y2

def draw_label(img, text, x, y, color=(255, 255, 255), bg=(0, 0, 0)):
    """Draws a text label with a background on an image."""
    (tw, th), _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
    cv2.rectangle(img, (x - 5, y - th - 5), (x + tw + 5, y + 5), bg, -1)
    cv2.putText(img, text, (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

def ensure_log_file(path):
    """Creates the log file and writes a header if it doesn't exist."""
    if not Path(path).exists():
        with open(path, "w") as f:
            f.write("--- PPE VIOLATION LOG ---\n")
            f.write("Timestamp           | Person ID | Zone      | Missing PPE\n")
            f.write("--------------------+-----------+-----------+-----------------\n")

# ----------------------------
# Main Detection Logic
# ----------------------------

def main(args):
    """Main function to run the PPE detection."""
    if args.log:
        ensure_log_file(args.log)

    # Load the YOLO model
    try:
        model = YOLO(args.model)
    except Exception as e:
        print(f"Error loading model: {e}")
        return

    # Open the video file
    cap = cv2.VideoCapture(args.video)
    if not cap.isOpened():
        print(f"Error: Cannot open video file at {args.video}")
        return

    # Initialize the DeepSort tracker
    tracker = DeepSort(max_age=70, n_init=3)

    # Get video properties
    W = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    H = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    FPS = cap.get(cv2.CAP_PROP_FPS)

    # Set up video writer to save the output
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(args.output, fourcc, FPS, (W, H))

    # =================================================================================
    # MODIFIED LOGIC: Dynamically determine which classes to detect and require
    # =================================================================================
    detect_classes_names = set()
    required_left_ppe = set()
    required_right_ppe = set()

    if args.classes_left:
        print(f"User specified classes for LEFT zone: {args.classes_left}")
        user_ppe_types_left = set()
        for cls_name in args.classes_left:
            canon_name = canonicalize(cls_name)
            if canon_name.startswith("no_"):
                user_ppe_types_left.add(canon_name[3:])
            else:
                user_ppe_types_left.add(canon_name)
        required_left_ppe = user_ppe_types_left
        print(f"Required PPE for LEFT zone set to: {required_left_ppe}")
    else:
        print("No specific classes provided for LEFT zone. Using fallback full PPE requirements.")
        required_left_ppe = DEFAULT_REQUIRED_LEFT

    if args.classes_right:
        print(f"User specified classes for RIGHT zone: {args.classes_right}")
        user_ppe_types_right = set()
        for cls_name in args.classes_right:
            canon_name = canonicalize(cls_name)
            if canon_name.startswith("no_"):
                user_ppe_types_right.add(canon_name[3:])
            else:
                user_ppe_types_right.add(canon_name)
        required_right_ppe = user_ppe_types_right
        print(f"Required PPE for RIGHT zone set to: {required_right_ppe}")
    else:
        print("No specific classes provided for RIGHT zone. Using fallback full PPE requirements.")
        required_right_ppe = DEFAULT_REQUIRED_RIGHT


    # For detection, we need to look for both the PPE and its violation class
    for ppe_type in required_left_ppe.union(required_right_ppe):
        detect_classes_names.add(ppe_type)
        detect_classes_names.add(f"no_{ppe_type}")

    # Always detect 'person' for tracking
    detect_classes_names.add("person")

    # Convert canonical class names to integer class indices for the model
    detect_class_indices = []
    model_class_map = {canonicalize(name): idx for idx, name in model.names.items()}

    for name in detect_classes_names:
        if name in model_class_map:
            detect_class_indices.append(model_class_map[name])
        else:
            print(f"Warning: Class '{name}' not found in model names.")


    if not detect_class_indices:
        print(f"Warning: None of the specified or default classes were found in the model.")
        print(f"Available classes: {list(model.names.values())}")
        return
    else:
        print(f"Model will detect the following classes: {[model.names[i] for i in detect_class_indices]}")
    # =================================================================================
    # END OF MODIFIED LOGIC
    # =================================================================================

    # Define the divider line (center of the screen)
    x_mid = W // 2
    divider = [x_mid, 0, x_mid, H]
    zone_names = ("LEFT", "RIGHT")

    frame_count = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        frame_count += 1

        # Pass the dynamically determined class indices to the model
        results = model.predict(frame, conf=args.conf, iou=0.5, classes=detect_class_indices, verbose=False)

        dets = results[0].boxes
        detections_for_tracker = []
        ppe_items = []

        if dets is not None and len(dets) > 0:
            for i in range(len(dets)):
                xyxy = dets.xyxy[i].cpu().tolist()
                cls_id = int(dets.cls[i].cpu().item())
                conf = float(dets.conf[i].cpu().item())
                class_name = canonicalize(model.names.get(cls_id, ""))

                if class_name == "person":
                    w, h = xyxy[2] - xyxy[0], xyxy[3] - xyxy[1]
                    detections_for_tracker.append(([xyxy[0], xyxy[1], w, h], conf, class_name))
                else:
                    ppe_items.append({"bbox": xyxy, "center": center_of_box(xyxy), "name": class_name})

        tracks = tracker.update_tracks(detections_for_tracker, frame=frame)

        for track in tracks:
            if not track.is_confirmed():
                continue

            track_id = track.track_id
            ltrb = track.to_ltrb()
            px1, py1, px2, py2 = map(int, ltrb)
            pcx, pcy = center_of_box(ltrb)

            side = point_side_of_line(pcx, pcy, *divider)
            zone = zone_names[0] if side > 0 else zone_names[1]

            required_ppe = required_left_ppe if zone == "LEFT" else required_right_ppe
            owned_ppe = {item["name"] for item in ppe_items if inside_bbox(item["center"], ltrb)}

            # Determine missing items based on required PPE for the zone
            missing_items = set()
            for required_item in required_ppe:
                # Check if the required item is NOT in the owned items, AND its 'no_' version is not detected
                # If the 'no_' version IS detected, it's definitely missing the required item.
                # If neither is detected, it's also missing the required item.
                if required_item not in owned_ppe and f"no_{required_item}" not in owned_ppe:
                     missing_items.add(required_item)
                # If the 'no_' version IS detected, the required item is missing.
                elif f"no_{required_item}" in owned_ppe:
                     missing_items.add(required_item)

            color = CLR_MISS if missing_items else CLR_OK
            cv2.rectangle(frame, (px1, py1), (px2, py2), color, 2)

            label_text = f"ID: {track_id} ({zone})"
            if missing_items:
                label_text += f" MISSING: {', '.join(sorted(list(missing_items)))}"
            else:
                label_text += " OK"

            bg_color = CLR_MISS_BG if missing_items else CLR_OK
            draw_label(frame, label_text, px1, py1 - 10, CLR_MISS_TEXT, bg_color)

            if missing_items and args.log:
                timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                missing_str = ", ".join(sorted(list(missing_items)))
                log_entry = f"{timestamp} | {track_id:<9} | {zone:<9} | {missing_str}\n"
                with open(args.log, "a") as f:
                    f.write(log_entry)

        cv2.line(frame, (divider[0], divider[1]), (divider[2], divider[3]), CLR_LINE, 2)
        cv2.putText(frame, zone_names[0], (divider[0] - 80, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, CLR_LINE, 2)
        cv2.putText(frame, zone_names[1], (divider[0] + 20, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, CLR_LINE, 2)

        cv2_imshow(frame)
        out.write(frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    out.release()
    cv2.destroyAllWindows()
    print(f"Processing complete. Output video saved to {args.output}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Selective PPE Detection using YOLOv8 and DeepSort.")
    parser.add_argument("--model", type=str, default="/content/best (3) (2).pt", help="Path to the YOLO model file.")
    parser.add_argument("--video", type=str, default="/content/drive/MyDrive/client_video/TATA1.mp4", help="Path to the input video file.")
    parser.add_argument("--output", type=str, default="output_video.mp4", help="Path to save the output video file.")
    parser.add_argument("--log", type=str, default="/content/log.txt", help="Path to save the violation log file. Set to empty ('') to disable logging.")
    parser.add_argument("--conf", type=float, default=0.3, help="Confidence threshold for object detection.")

    # --- MODIFIED LINE ---
    # Added separate arguments for left and right zone classes
    parser.add_argument(
        "--classes_left",
        nargs='*',
        default=["helmet"],
        help="A list of specific classes to check for in the LEFT zone. Defaults to all required if not specified."
    )
    parser.add_argument(
        "--classes_right",
        nargs='*',
        default=["safety_vest"],
        help="A list of specific classes to check for in the RIGHT zone. Defaults to all required if not specified."
    )


    args, unknown = parser.parse_known_args()
    main(args)

from google.colab import files
files.download('/content/output_video.mp4')

"""***USER BASED DETECTION WITHOUT ZONE:***"""

import cv2
import time
import datetime
from pathlib import Path
from ultralytics import YOLO
from deep_sort_realtime.deepsort_tracker import DeepSort
import argparse
from google.colab.patches import cv2_imshow


# ----------------------------
# CONFIG
# ----------------------------

# --- Class & Color Configuration ---
# This dictionary acts as a fallback set of requirements if the user
# provides an empty --classes argument.
DEFAULT_REQUIRED_PPE  = {"helmet", "shoes", "goggles", "safety_vest", "pvc_suit"}

# Class name aliases to normalize names from the model to a standard form.
ALIASES = {
    "person": {"person", "Person"},
    "helmet": {"helmet", "hardhat", "safety_helmet", "Helmet"},
    "safety_vest": {"vest", "safety_vest", "Safety_Vestr"},
    "no_helmet": {"no_helmet", "no_safety_helmet", "no_hardhat", "NO_helmet"},
    "no_safety_vest": {"no_vest", "no_safety_vest", "NO_Vestr"},
    "pvc_suit": {"pvc_suit", "suit"},
    "no_pvc_suit": {"no_pvc_suit", "no_suit"},
    "shoes": {"shoes", "safety_shoes", "boots","Safety Shoes"},
    "goggles": {"goggles", "safety_goggles", "glasses", "eye_protection","Safety Goggles"},
    "no_safety_shoes": {"no_shoes", "NO_safetyshoes", "no_boots", "no_safety_shoes"},
    "no_goggles": {"no_goggles", "NO_goggles", "no_eye_protection", "no_safety_goggles"},
}

# --- Visual Configuration ---
CLR_OK = (0, 200, 0)
CLR_MISS = (0, 0, 255)
CLR_MISS_TEXT = (255, 255, 255)
CLR_MISS_BG = (0, 0, 255)

# ----------------------------
# Helper Functions
# ----------------------------

def canonicalize(name: str) -> str:
    """Converts a class name to its canonical form using the ALIASES map."""
    n = name.lower().replace(" ", "_")
    for canon, synonyms in ALIASES.items():
        if n == canon or n in synonyms:
            return canon
    return n

def center_of_box(xyxy):
    """Calculates the center point of a bounding box."""
    x1, y1, x2, y2 = xyxy
    return (int((x1 + x2) / 2), int((y1 + y2) / 2))

def inside_bbox(point, bbox):
    """Checks if a point is inside a bounding box."""
    px, py = point
    x1, y1, x2, y2 = bbox
    return x1 <= px <= x2 and y1 <= py <= y2

def draw_label(img, text, x, y, color=(255, 255, 255), bg=(0, 0, 0)):
    """Draws a text label with a background on an image."""
    (tw, th), _ = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)
    cv2.rectangle(img, (x - 5, y - th - 5), (x + tw + 5, y + 5), bg, -1)
    cv2.putText(img, text, (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

def ensure_log_file(path):
    """Creates the log file and writes a header if it doesn't exist."""
    if not Path(path).exists():
        with open(path, "w") as f:
            f.write("--- PPE VIOLATION LOG ---\n")
            f.write("Timestamp           | Person ID | Missing PPE\n")
            f.write("--------------------+-----------+-----------------\n")

# ----------------------------
# Main Detection Logic
# ----------------------------

def main(args):
    """Main function to run the PPE detection."""
    if args.log:
        ensure_log_file(args.log)

    try:
        model = YOLO(args.model)
    except Exception as e:
        print(f"Error loading model: {e}")
        return

    cap = cv2.VideoCapture(args.video)
    if not cap.isOpened():
        print(f"Error: Cannot open video file at {args.video}")
        return

    tracker = DeepSort(max_age=70, n_init=3)

    W = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    H = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    FPS = cap.get(cv2.CAP_PROP_FPS)

    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(args.output, fourcc, FPS, (W, H))

    # --- Simplified Logic: Determine required classes for the whole frame ---
    detect_classes_names = set()
    required_ppe = set()

    if args.classes:
        print(f"User specified classes: {args.classes}")
        user_ppe_types = set()
        for cls_name in args.classes:
            canon_name = canonicalize(cls_name)
            if canon_name.startswith("no_"):
                user_ppe_types.add(canon_name[3:])
            else:
                user_ppe_types.add(canon_name)

        required_ppe = user_ppe_types
        print(f"Required PPE for all zones set to: {required_ppe}")

        for ppe_type in required_ppe:
            detect_classes_names.add(ppe_type)
            detect_classes_names.add(f"no_{ppe_type}")
    else:
        print("No specific classes provided. Using fallback full PPE requirements.")
        required_ppe = DEFAULT_REQUIRED_PPE
        for ppe_type in required_ppe:
            detect_classes_names.add(ppe_type)
            detect_classes_names.add(f"no_{ppe_type}")

    detect_classes_names.add("person")

    detect_class_indices = []
    model_class_map = {canonicalize(name): idx for idx, name in model.names.items()}
    for name in detect_classes_names:
        if name in model_class_map:
            detect_class_indices.append(model_class_map[name])

    if not any(model.names[i] == 'person' for i in detect_class_indices):
         print("Warning: 'person' class not found or not selected. Tracking will not function.")

    print(f"Model will detect the following classes: {[model.names[i] for i in detect_class_indices]}")
    # --- End of Simplified Logic ---

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Pass the dynamically determined class indices, confidence, and IOU to the model
        results = model.predict(frame, conf=args.conf, iou=args.iou, classes=detect_class_indices, verbose=False)

        dets = results[0].boxes
        detections_for_tracker = []
        ppe_items = []

        if dets is not None and len(dets) > 0:
            for i in range(len(dets)):
                xyxy = dets.xyxy[i].cpu().tolist()
                cls_id = int(dets.cls[i].cpu().item())
                conf = float(dets.conf[i].cpu().item())
                class_name = canonicalize(model.names.get(cls_id, ""))

                if class_name == "person":
                    w, h = xyxy[2] - xyxy[0], xyxy[3] - xyxy[1]
                    detections_for_tracker.append(([xyxy[0], xyxy[1], w, h], conf, class_name))
                else:
                    # Only consider PPE detections above the confidence threshold
                    if conf >= args.conf:
                        ppe_items.append({"center": center_of_box(xyxy), "name": class_name})

        tracks = tracker.update_tracks(detections_for_tracker, frame=frame)

        for track in tracks:
            if not track.is_confirmed():
                continue

            track_id = track.track_id
            ltrb = track.to_ltrb()
            px1, py1, px2, py2 = map(int, ltrb)

            owned_ppe = {item["name"] for item in ppe_items if inside_bbox(item["center"], ltrb)}
            missing_items = set()

            all_owned_ppe_base_names = {item[3:] if item.startswith("no_") else item for item in owned_ppe}
            missing_items.update(required_ppe - all_owned_ppe_base_names)

            for item in owned_ppe:
                if item.startswith("no_") and item[3:] in required_ppe:
                     missing_items.add(item[3:])

            color = CLR_MISS if missing_items else CLR_OK
            cv2.rectangle(frame, (px1, py1), (px2, py2), color, 2)

            label_text = f"ID: {track_id}"
            if missing_items:
                label_text += f" MISSING: {', '.join(sorted(list(missing_items)))}"
            else:
                label_text += " OK"

            bg_color = CLR_MISS_BG if missing_items else CLR_OK
            draw_label(frame, label_text, px1, py1 - 10, CLR_MISS_TEXT, bg_color)

            if missing_items and args.log:
                timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                missing_str = ", ".join(sorted(list(missing_items)))
                log_entry = f"{timestamp} | {track_id:<9} | {missing_str}\n"
                with open(args.log, "a") as f:
                    f.write(log_entry)

        cv2_imshow(frame)
        out.write(frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    out.release()
    cv2.destroyAllWindows()
    print(f"Processing complete. Output video saved to {args.output}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Selective PPE Detection using YOLOv8 and DeepSort.")
    parser.add_argument("--model", type=str, default="/content/best (3) (2).pt", help="Path to the YOLO model file.")
    parser.add_argument("--video", type=str, default="/content/drive/MyDrive/client_video/TATA1.mp4", required=True, help="Path to the input video file.")
    parser.add_argument("--output", type=str, default="output_video.mp4", help="Path to save the output video file.")
    parser.add_argument("--log", type=str, default="log.txt", help="Path to save the violation log file. Set to '' to disable.")
    parser.add_argument("--conf", type=float, default=0.3, help="Confidence threshold for object detection. Increase this to reduce false positives.")
    parser.add_argument("--iou", type=float, default=0.5, help="IoU threshold for non-maximum suppression. Adjust this to control overlapping bounding boxes.")


    parser.add_argument(
        "--classes",
        nargs='*',
        default=["helmet", "shoes"],
        help="A list of specific classes to check for. Defaults to 'helmet' and 'pvc_suit'."
    )

    args = parser.parse_args(args=["--video", "/content/drive/MyDrive/client_video/TATA1.mp4"]) # Added --video argument
    main(args)

from google.colab import files
files.download('/content/output_video.mp4')